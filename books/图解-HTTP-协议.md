## HTTP协议

HyperText Transfer Protocol 超文本传输协议  
TCP/IP 是互联网相关的各类协议族的总称。 `IP,ICMP,IEEE 802.3,PPPoE,DNS,TCP,FDDI,UDP,FTP,SNMP,HTTP`  

应用层：决定向用户提供应用服务时通信的活动。  `FTP,DNS,HTTP`  

传输层：对上层 `应用层`，提供处于网络连接中的两台计算机之间的数据传输。  

> TCP，传输控制协议。UDP 用户数据报协议。   

网络层（IP，选择传输路线），数据链路层（ARP,`RARP：IP -> MAC` 硬件部分）。  

## 通信传输流
HOC
**客户端**  
应用层：发HTTP请求  
传输层 TCP：分割HTTP报文，在报文打上标记序号和端口号  
网络层 IP: 增加目的地的MAC地址后转发到链路层  

> 发送端层与层之间传输数据时，**每经过一层打上该层所属的首部信息**，反之，接收端每经过一层将对应首部消去。  

TCP协议为了更容易`传输大数据`才将数据分割，而且TCP协议能够`确认`数据最终是否送达到对方。  

## TCP

**三次握手：**

```js
发送端：SYN
接收端：SYN/ACK
发送端：ACK
```

**四次挥手：**

```js
主动断开方：FIN
被动断开方：ACK
被动断开方：FIN
主动断开方：ACK
```

## DNS

**查找顺序**：浏览器缓存区 --> 操作系统 --> hosts --> DNS服务器   

URI，统一资源标识符  
URL，统一资源定位符  
URL是URI的子集。  

绝对URL：协议+登录信息（可选）+服务器地址+端口+资源路径  

## 请求报文

```js
请求报文 = 请求方法 + 请求URI + 协议版本 + 请求头 + 内容实体
响应报文 = 协议版本 + 状态码 + 状态码原因短语（ok，not found） + 响应头 + 内容实体
```

HTTP协议自身不具备保存之前发送过的请求或响应的功能：`即无状态协议`

## if-modified-since

假设请求 `www.hacker.jp/index.html`  
响应头为：`If-Modified-Since:Thu,12 Jul 2012 07:30:00 GMT`  

**表示**：仅返回指定时间（2012，07，12）以后更新过的index.html页面，如果未更新，则以状态码`304 Not Modified`返回  

## 请求方法

#### 1. PUT： 传输文件（不带验证机制，任何人都可以上传，一般不采用该方法）

客户端：put /example.html  
服务端：204 No Content， 该example.html已存在服务器上  

#### 2. HEAD：获取报文首部  

类似Get方法，只是`不返回报文头部，用于确认URI的有效性和资源更新的日期时间`

#### 3.DELETE方法：删除文件

同PUT一样不带验证机制，一般不使用  

#### 4.OPTIONS 询问服务端支持的请求方法

响应：`Allow：GET,POST,HEAD,OPTIONS`

#### 5.TRACE：追踪路径

发送请求时，在Max-Forwards填入数值 ( TTL？)，每经过一次服务器（**包括代理服务器**）数字减一，减到0时停止传输，最后接受请求的服务器（**可能是代理服务器**）响应200 OK，并在响应主体中返回该 *最终服务器* 收到的原始请求报文。    

对于客户端来说，就能知道从它这里发出去的报文，在该报文最终停止传输时，变成了什么样的报文。  

#### 6.CONNECT：要求用隧道协议连接代理服务器。SSL+TLS

## 持久连接

HTTP/1.1默认持久连接，HTTP/1.0未标准化，持久化需要客户端和服务器端同时支持。  

**http keep-alive**
只要任意一端没有明确提出断开连接，则保持TCP连接状态。减轻了TCP连接中重复建立和断开所造成的额外开销，同时请求响应更快结束，WEB页面显示速度也能提高。  

## 管线化  

不用等待上一个请求响应可直接发送下一个请求  

## cookie

服务器端，设置响应头字段 Set-Cookie，通知客户端保存cookie。下次客户端向服务端发送请求时，客户端自动在请求报头中加入cookie。  

## HTTP报文结构

编码提升传输速率。  

实体 = 实体首部 + 实体主体。通常报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容发生变化，才导致和报文主体产生差异。  

内容编码：`gzip，compress，deflate（zlib），identity（不进行编码）`  

------

分块传输编码，传输大容量数据时，把数据分割成多块，能够让浏览器逐步显示页面。  

MIME：多用途因特网邮件扩展，允许处理文字，图片，视频等多个不同类型的数据。  
MIME中采用称为`多部分对象集合`的方法，容纳多份不同类型的数据。  

multipart / form-data ，web表单文件上传时使用。  

范围请求：指定需要下载的实体范围（例如：下载中断恢复下载），`Range`字段指定资源的byte范围。对于范围请求，服务端响应206 Partial Content的响应报文。  

## 内容协商

例如，返回**对应浏览器语言的web页面**：  

客户端和服务端就响应的资源内容进行交涉。 内容协商以 `语言，字符集，编码方式` 为基准判断响应的资源。

```js
Accept
Accept-Charset
Accept-Encoding
Accept-Language
Content-Language
```

# HTTP状态码

| 状态码 | 类别             | 原因短语                   |
| ------ | ---------------- | -------------------------- |
| 1xx    | 信息性状态码     | 接收的请求正在处理         |
| 2xx    | 成功状态码       | 请求正常处理完毕           |
| 3xx    | 重定向状态码     | 需要进行附加操作以完成请求 |
| 4xx    | 客户端错误状态码 | 服务器无法处理该请求       |
| 5xx    | 服务器错误状态码 | 服务器处理请求出错         |

------

```js
200 ok:请求正常处理
204 No Content: 请求处理成功，但没有资源可返回。
206 Partial Content：范围请求成功。
301 Moved Permanently：永久性重定向，请求的资源已经被分配了新的URI，此时应该按照Location首部字段提示的URI重新访问。
302 Found:临时性重定向
301和302的区别：用户把URI保存为书签，不会像301出现一样更新书签，而是依旧保留302页面的URI。
303 See Other: 表示请求对应的资源存在着另一个URI，应使用GET方法定向获取该资源。
当301，302，303状态码返回时，就几乎所有的浏览器都会把POST改成GET，并删除请求报文的主题，之后再次发送请求。

304 Not Modified：服务端资源未改变，直接使用客户端未过期的缓存。
400 Bad Request: 请求报文中存在语法错误。
401 Unauthorized: 发送的请求需要有通过HTTP,BASIC,DIGEST的认证信息。响应需包含，WWW-Authenticate首部以弹出认证用的对话窗口。
403 Forbidden: 对请求资源的访问被服务器拒绝（未获得文件系统的访问授权，从未授权的发送源IP进行访问）都是发生403的原因。
404 Not Found。
500 Internal Server Error。内部服务器出错。
503 Service Unavailable,服务器超负荷或停机维护， Retry-After字段告知再次尝试时间。
```

## web服务器

HTTP通信时，除了客户端和服务器之外，还有一些用于通信数据转发的应用程序，比如 `代理，网关，隧道`。  

代理：应用程序，服务器和客户端之间的中间人。  
网关：服务器，接受从客户端发送过来的请求时，就像自己拥有资源的原服务器一样对请求进行处理。  
隧道：相隔很远的客户端和服务器之间进行中转，并保持双方通信连接。  

代理：通过代理服务器进行转发请求或相应时，会追加via首部信息。  
优点：利用缓存技术减少网络宽带的流量，组织内部对特定网站的访问控制，以获取访问日志为主要目的。  
缓存代理；当代理转发响应时，缓存代理会预先把资源副本缓存到代理服务器上，下次请求就可以将缓存结果直接返回,（会想向原服务器确定资源的有效性）。  
透明代理：不对请求做任何处理.  

网关：使通信线路上的服务器提供非HTTP协议服务。提高安全性。  

## HTTP首部

**通用首部字段：**

| 字段              | 说明                       |
| ----------------- | -------------------------- |
| Cache-Control     | 控制缓存的行为             |
| Connection        | 逐跳首部，连接的管理       |
| Date              | 创建报文的日期时间         |
| Pragma            | 报文指令                   |
| Trailer           | 报文末端的首部一览         |
| Transfer-Encoding | 指定报文主体的传输编码方式 |
| Upgrade           | 升级为其他协议             |
| Via               | 代理服务器的相关信息       |
| Warning           | 错误通知                   |

------

**请求首部字段：**

| 字段                | 说明                                          |
| ------------------- | --------------------------------------------- |
| Accept              | 用户代理可处理的媒体类型                      |
| Accept-Charset      | 优先的字符集                                  |
| Accept-Encoding     | 优先的内容编码                                |
| Accept-Language     | 优先的语言                                    |
| Authorization       | Web认证信息                                   |
| Expect              | 期待服务器的特定行为                          |
| From                | 用户的电子邮箱地址                            |
| Host                | 请求资源所在服务器                            |
| If-Match            | 比较实体标记（ETag）                          |
| If-Modified-Since   | 比较资源的更新时间                            |
| If-None-Match       | 比较实体标记，与if-match相反                  |
| If-Range            | 资源未更新时发送实体Byte的范围请求            |
| If-Unmodified-Since | 比较资源的更新时间（与if-modified-since相反） |
| Max-Forwards        | 比较传输逐跳数                                |
| Proxy-Authorization | 代理服务器要求客户端的认证信心                |
| Range               | 实体的字节范围请求                            |
| Referer             | 对请求的URI的原始获取方                       |
| TE                  | 传输编码的优先级                              |
| User-Agent          | HTTP客户端程序的信息                          |

------

**响应首部字段：**

| 字段               | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否可接受字节范围请求       |
| Age                | 推算资源创建经过时间         |
| ETag               | 资源的匹配信息               |
| Location           | 令客户端重定向至指定URI      |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 对在此发起请求的时机要求     |
| Server             | HTTP服务器的安装信息         |
| Vary               | 代理服务器缓存的管理信息     |
| WWW-Authenticate   | 服务器对客户端的认证信息     |

------

**实体首部字段：**针对请求报文和响应报文的【实体】部分使用的字段。即针对请求数据和返回数据的 `要求`。

| 字段             | 说明                        |
| ---------------- | --------------------------- |
| Allow            | 资源支持的HTTP方法          |
| Content-Encoding | 实体主体适用的编码方式      |
| Content-Language | 实体主体的自然语言          |
| Content-Length   | 实体主体的大小 单位（字节） |
| Content-Location | 替代对应资源的URI           |
| Content-MD5      | 实体主体的报文摘要          |
| Content-Range    | 实体主体的位置范围          |
| Content-Type     | 实体主体的媒体类型 ,request时代表请求发送的数据类型，response时代表返回的数据类型         |
| Expires          | 实体主体过期的日期时间      |
| Last-Modified    | 资源的最后修改时间          |

------

**端对端首部:** 分在此类别的字段，会转发给请求、响应的最终目标。  

**逐跳首部：** 只对单次转发有效，会因为缓存或者代理而不再转发。  

**逐跳字段：** Connection，Keep-Alive，Proxy-Authenticate,Proxy-Authorization,Trailer,TE,Transfer-Encoding,Upgrade.  
*[除以上字段，均为端对端首部]*

### Cache-Control

通过指定首部字段的`Cache-Control` 的指令，就能操作缓存的工作机制。指令参数可选，多个指令之间通过`,`分隔，可用在 **请求以及响应** 时。

> Cache-Control: private, max-age=0,no-cache.    

1. 缓存，请求指令

| 指令             | 参数   | 说明                         |
| ---------------- | ------ | ---------------------------- |
| no-cache         | 无     | 强制向源服务器再次验证       |
| no-store         | 无     | 不缓存请求或响应的任何内容   |
| max-age = [秒]   | 必需   | 响应的最大Age值              |
| max-stale(=[秒]) | 可省略 | 接收已过期的响应             |
| min-fresh=[秒]   | 必需   | 期望在指定时间内的响应仍有效 |
| no-transform     | 无     | 代理不可更改的媒体类型       |
| only-if-cached   | 无     | 从缓存获取资源               |
| cache-extension  | -      | 新指令标记（token）          |

------

1. 缓存，响应指令

| 指令             | 参数   | 说明                                           |
| ---------------- | ------ | ---------------------------------------------- |
| public           | 无     | 可向任意方提供响应的缓存                       |
| private          | 可省略 | 仅向特定用户返回响应                           |
| no-cache         | 可省略 | 缓存前必需先（向服务器）确认其有效性           |
| no-store         | 无     | 不缓存请求或响应的任何内容                     |
| no-transform     | 无     | 代理不可更改媒体类型                           |
| must-revalidate  | 无     | 可缓存但必须向源服务器进行确认                 |
| proxy-revalidare | 无     | 要求中间缓存服务器对缓存的响应有效性再进行确认 |
| max-age=[秒]     | 必需   | 响应的最大Age值                                |
| s-maxage=[秒     | 必需   | 公共缓存服务器响应的最大Age值                  |
| cache-extension  | -      | 新指令标记（token）                            |

表示是否能缓存的指令：`public,private,no-cache` 。  

`no-cache` 实际上代表【不缓存过期的资源】，而`不是不缓存（no-store）` 缓存会向源服务器进行有效期确认后处理资源。  

由服务器返回的响应中，如果报文首部字段 Cache-Control中对no-cache字段指定参数，`cache-control: no-cache=Location` 则客户端不能使用缓存。 换言之，如果没有参数值的首部字段可以使用缓存。  

控制可执行缓存的对象的指令：`no-store,  s-maxage，max-age,min-fresh,max-stale,only-if-cached(504 gateway timeout),must-revalidate(504),proxy-revalidate,on-transform(防止缓存或代理压缩图片).`  

1. 当使用`on-store`指令时，暗示请求或响应中包含机密信息，规定缓存不能在本地存储请求或响应的任一部分。

2. s-maxage和max-age功能相同，区别在于s-maxage指令只适用于供多位用户使用的代理服务器。对同一用户重复返回响应的服务器来说，指令无效。当使用s-maxage时，expires首部字段和max-age字段无效.      

   `cache-control:max-age = 604800`  
   客户端的角度（向缓存服务器）: 要是缓存过期没超过一周，就把它给我。  
   服务器角度（向缓存服务器）：一周以内不必向我确认，缓存服务器直接处理缓存。  
   `max-age:`  如果判定缓存资源的缓存时间数值比指定时间的数值更小，则使用缓存。`max-age=0` ,则缓存服务器需要向源服务器请求。  

   `cache-extension token,扩展cache-control首部字段的指令。`

### Connection

1. 用于控制不再转发的首部字段名。  

```js
Upgrade: http/1.1
Connection:Upgrade
```

则代理服务器接收到这两个字段时，不会继续转发这两个字段 (`Upgrade, Connection` ) 到源服务器。

1. 管理持久连接:

   http/1.1默认都是持久连接keep-alive，当服务端 明确要断开连接时，则指定connection:close.   

   旧版本想使用持久连接，则客户端指定connection:keep-alive，此时服务端会加上首部字段 `keep-alive:timeout=10,max=500`  后返回响应。

### Pragma：no-cache

HTTP/1.1之前的遗留, 存在于客户端发送的请求中，表示不接受缓存。  
为了兼容所有协议的服务器，采用 `cache-control:no-cache,pragma:no-cache`

### Upgrade 

用于检测 **HTTP协议及其他协议** 是否可使用更高的版本。    

```
客户端：
Upgrade:TLS/1.0
//指定中间服务器不转发Upgrade字段，使得Upgrade（只限于客户端和最终服务器）能转发到源服务器。
Connection:Upgrade 

服务器端：  
101 Switching Protocols
```

### via 

追踪客户端与服务器之间的请求和响应报文的传输路径，各个代理服务器会往 ` Via首部` 添加自身服务器的信息。

### warning

告知用户一些与缓存相关的问题的警告。  

## 请求首部字段

用于 **补充** 请求的附加信息，客户端信息，对响应内容相关的优先级等内容。

### Accept  

通知服务器，用户代理（客户端）能够处理的媒体类型及媒体类型的优先级：  

q为0到1，代表权重，不指定默认为1，1的优先级最高。  

### Expect

客户端告知服务器，期望出现某种特定的行为。服务器无法理解时，返回 `471 Expection Failed` 

可利用此字段，写明所期望的扩展。  

### If-Match 

IF-xxx 条件请求，只有判断指定条件为真，服务器才会执行请求。实体标记 `ETag` 是与特定资源关联的确定值，资源更新后ETag也会更新。服务器对比 `If-Match` 字段值和 `资源ETag` 的值，只有当一致时，才执行请求。`If-Match:"*"` 代表只要有资源存在就处理请求。

### if-modified-since

在if-modified-since指定时间之后，资源发生了更新，服务器才接受请求，否则返回 `304`   

get,head方法中，`if-none-match`  用于获取最新的资源。

### if-unmodified-since 

告知服务器，指定的请求资源只有在字段值内指定的时间日期之后，未发生更新的情况下，才能处理请求。

## 响应首部字段

服务器端向客户端返回响应报文中所使用的字段，补充响应的附加信息，服务器信息，以及对客户端的附加要求。

### accept-ranges

```js
accept-ranges:none 不能接受范围请求
accept-ranges:bytes 可以接受范围请求
```

### Age 

源服务器多久前创建了响应，单位为s，如果创建响应的服务器是缓存服务器，Age是指缓存后的响应再次 **发起认证**  到  **认证完成**  的时间值。

### ETag

强ETag值，无论发生多么细微的变化都会改变其值。  
弱ETag值，只用于提示资源是否相同，只有资源发生根本改变，产生差异时才会改变ETag值，此时字段开始处附加 `W/`

### Location 

响应接收方，引导至某个与请求URI位置不同的资源，通常与3XX，重定向响应配合使用。

### Retry-After

*单位s*   配合503，或3xx，告诉客户端应该在多久之后再次发送请求。

### server  

当前服务器上安装的HTTP服务器应用程序的信息 例如：apache

## 实体首部字段

### content-encoding

会告知客户端， 服务器对实体主体部分选用的内容编码方式。 内容编码：在不丢失实体信息的前提下所进行的压缩。采用内容编码传输时，不再使用 content-length 计算内容大小。

### Content-MD5 

确保报文主体是否被篡改

### Content-Type

报文主体的媒体类型

### expires

服务端将资源的 **过期时间** 告知客户端。缓存服务器在收到 `expires` 字段的响应后，会以缓存来应答请求，在expires字段指定的时间之前，响应的副本会一直保存，当超过指定时间之后，缓存服务器将向源服务器请求资源。  

**源服务器不希望缓存服务器缓存资源时** ，最好在expires字段写入与 Date 字段相同的时间值。  

> Cache-control 有指定max-age指令时，比起 expires ，会**优先处理max-age** 。 设置max-age:0 则不使用缓存。

## 有关cookie的字段

set-cookie: 响应首部字段，开始状态管理所使用的cookie信息。

| 属性         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NAME=VALUE   | 赋予Cookie的名称和值                                         |
| expires=DATE | cookie的有效期，不指定则默认浏览器关闭就失效                 |
| path=PATH    | 将服务器的文件目录作为cookie的适用对象，不指定则默认文档所在的文件目录 |
| domain=域名  | 作为cookie适用对象的域名，不指定则默认创建cookie的服务器的域名 |
| secure       | 仅在https安全通信时才发送cookie                              |
| httponly     | 使cookie不能被js脚本访问                                     |

一旦 cookie 从服务端发送至客户端，服务端就 **不存在可以显示删除cookie** 的方法，但是可通过 **覆盖已过期的cookie** ，实现对客户端cookie的实质性删除。

## 其他首部字段

`X-Frame-Options:` 用于控制网站内容在其他web网站的frame内的显示问题。 可选值：`Deny | SAMEORIGIN`  
`X-XSS-Protection:`  针对XSS 跨站脚本攻击.  可选值：`0 | 1`  
`DNT：do not track:`  拒绝被精准广告追踪   `0 | 1`  
`P3P：`  在线隐私偏好平台，让个人隐私变成仅供程序可理解的形式。

## HTTPS 

HTTPS = HTTP+加密 + 证书 + 完整性保护  

**HTTP不足：**

1. 通信使用明文（不加密），内容可能会被窃听
2. 不验证通信方身份，因此有可能遭遇伪装
3. 无法证明报文的完整性，所以有可能已遭篡改

**通信的加密：**

1. HTTP协议中没有加密机制，但可以通过和SSL（安全套接层）或TLS(安全传输层协议)的组合使用，加密HTTP的通信内容。
2. 用SSL建立安全的通信线路之后，就可以在这条线路上进行HTTP通信了， 与SSL组合使用的HTTP被称为HTTPS。

### 证书

用于确认通信方，证书由值得信任的第三方机构颁发。通过使用证书，以证明通信方就是意料中的服务器。客户端持有证书即可完成个人身份的确认，可用于对WEB网站的认证环节。

在请求或响应的传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击 ( MITM ) 。`防止篡改：PGP,MD5`



通常 HTTP 直接与 TCP 通信，当使用 SSL 时，则变成先和 SSL 通信，再由 SSL 和 TCP 通信。https 是身披 SSL 外壳的HTTP，SSL独立于HTTP协议，所以其他运行在应用层的SMTP和TELNET等协议均可配合SSL协议使用。SSL是当今世界上最为广泛的网络安全技术。

## 密码

对称密码学：共享秘钥加密，加密和解密都是同一个秘钥。（如何秘密的传递秘钥？）  
非对称密码学：公开密钥加密， 公钥和私钥。（效率低）  

发送方，利用【接收方的公钥】进行加密，然后接收方接收到之后利用自己的【秘钥】进行解密。  

HTTPS采用共享密钥加密和公开密钥加密混合的方式。

1. 使用非对称密码学，安全的交换对称密码学的秘钥。
2. 采用对称密码学进行信息的通信。

HTTPS 的加密通信会消耗更多的CPU和内存资源，每次通信都加密，会消耗相当多的资源。因此非敏感信息则使用HTTP通信，敏感信息才使用HTTPS。  

## 认证

BASIC认证，基本认证。  
DIGEST认证，摘要认证。  
SSL客户端认证。  
FormBase认证，基于表单认证。  

1. BASIC（不常用）

```js
1. 客户端请求
2. 服务端返回401 Authorization Required，同时返回WWW-Authenticate信息
3. 客户端用户名ID+密码进行BASE64编码（不安全），字段为Authorization：
4. 服务端返回200或401.

另外想再进行一次BASIC认证时，一般浏览器无法实现认证注销操作。
```

1. DIGEST 弥补BASIC的缺点。(不常用)

```js
客户端：发起认证。
服务端：发送质询码
客户端：通过质询码计算出响应码
```

## session管理及cookie应用

客户端发送登录信息，服务器利用 `session` 记录登录信息，并生成 `session ID` 发送给客户端，客户端记录 `session id` 到 `cookie` 中, 客户端下次请求带上cookie。

## HTTP功能追加

消除HTTP瓶颈的 `SPDY`  

**HTTP标准**

1. 一条连接上只可发送一个请求。
2. 请求只能从客户端开始，客户端不可以接收除响应之外的指令。
3. 请求、响应首部未经压缩就发送，首部信息越大延迟越大。
4. 发送冗长的首部，每次相互发送相同的首部造成的浪费越大。
5. 可任意选择数据压缩格式，非强制压缩发送。
6. AJAX
7. Comet 服务器推：  
   通常服务器收到请求，处理完毕后立即返回响应，但是为了实现推送，Comet会将响应置于挂起状态，当服务器有内容更新时，再返回该响应。
8. SPDY
   1. 多路复用，一条TCP处理多个HTTP请求。
   2. 请求优先级。
   3. 压缩HTTP首部。
   4. 推送功能。
   5. 服务器提示功能，主动提示客户端请求所需的资源。

## websocket 全双工通信

客户端发起连接，之后服务端和客户端任意一方都可以向对方发送请求。  

```js
请求：Upgrade
响应：101 Switching Protocols
```

## HTTP 2.0 2014年标准化

```js
Http Speed + Mobility
Network-Friendly HTTP Upgrade
```



**WEB DAV:** 对服务器上的内容直接进行复制，编辑等操作的分布式文件系统。

**防火墙：** 禁止非指定的 `协议和端口号` 的数据包通过，因此过去的新系统如果使用了新的端口或者协议，则必须修改防火墙设置。  

**CGI:** `Common Gateway Interface 通用网关接口` Web服务器在接收到客户端发送过来的请求后转发给程序的一组机制。  

使用 CGI 的程序叫做 CGI 程序，如 `PHP,Perl，Ruby，C` 等编写而成。之前提到的CGI，每次接收到请求，程序都得启动一次，因此访问量大的时候服务器会有相当大的负载。而Servlet运行在与服务器相同的进程中，负载较小。

## 发布更新信息的RSS/Atom

RSS 简易信息聚合，聚合内容。

## Web的攻击技术

**主动攻击:** SQL注入，QS命令注入  
**被动攻击：**XSS跨站脚本攻击，CSR:跨站伪请求攻击

**XSS：** 运行非法的 HTML 标签或 JS ,或在URL中插入script