## 1. 计算器概论

1. 计算机硬件  

冯诺依曼架构: 控制器，运算器，存储器，输入设备，输出设备。其中 `控制器，运算器` 都是在 `cpu`中。  

cpu为一个具有特定功能的芯片，里头包含有微指令集。如果要主机实现某些特定功能，需要参考这颗CPU是否有相关内建的微指令集。  

cpu用于运算和判断，运算的数据完全来源于主存储器（内存），主存的数据来源于输入单元，cpu处理完之后写回主存，由主存传输到输出单元。  
`tips`: 要加快系统性能，需要加大内存，因为所有的数据都要经过主存储器的传输。  

2. cpu架构  

精简指令集(RISC),每个指令运行时间很短，完成的动作纯粹，复杂任务需要多个指令完成。  

复杂指令集(CISC)，可以执行低阶的硬件操作，指令数目多且复杂，花费时间长，处理的任务较为丰富。常见的是AMD,Intel的x86架构。  

x86：因为最早的Intel发展出来的cpu代号为8086，后来依次有80286,80386.后来x86结构的cou由8位升级到16位，32位，最终产生了64位cpu，因此64位的cpu又被统称为x86_64。  
tips: cpu的位即cpu一次性能读写的最大量，64位表示一次性，能读写64bit的数据。  

记忆单元：包含主存储器RAM与辅助存储，辅助存储即硬盘，光碟，磁带等。  

cpu的数据源统统来自于主存储器，如果需要由过去的经验来判断事情，则需要将经验（硬盘）的数据加载到主存中，再交由cpu处理。  

3. 单位速度  

* 容量  

0/1二进制单位称为bit,通常储存数据需要 8bit = 1Byte 字节。  

B => KB => MB => GB => TB => PB => EB => ZB  (间隔 1024倍)  

* 速度  

cpu的指令周期使用 MHz 或者 GHz， Hz为秒分之1，网络的传输单位为Mbps，Mbits per second。即每秒传输多少bit。所有20M的宽带为 20/8 = 2.5Mbyte的上传下载速度。  

硬盘500G实际是10进制单位即，500*1000*1000 Byte。而转换为文件单位时，使用二进制，变成了466 GB。  

4. 个人计算机  

主板是连接各个组件的一个重要项目，因此主板上沟通各组件的`芯片组`设计优劣，就会影响到性能。  

北桥：负责连接速度快的CPU，主存，与显示适配器。  
南桥：负责连接速度慢的硬盘，usb，网卡等。  

目前主流的架构中，大多将北桥整合到cpu中。  

CPU频率，即CPU每秒可以进行工作的次数，频率越高代表单位时间内可以做更多的事情，CPU频率3.6GHz，代表这颗CPU一秒可以进行3.6*10^9次工作。  

超线程（Hyper-Threading: HT）：通过让CPU竞争计算单元，比如4核的机器，通过HT可以让操作系统认为是8核，因此可以同时运作八个程序。  

5. 操作系统  

* 操作系统核心直接参考硬件规格写成，所以同一个操作系统程序不能够在不一样的硬件架构下运作。  
* 应用程序的开发都是参考操作系统提供的开发接口，所以该应用程序只能在该操作系统上面运作而已，不能够在其它操作系统上运行。  

## 2. Linux
### 版本  
| | RPM 软件管理 | DPKG 软件管理
:-- |:-- |:--
| 商业公司 | RHEL (Red hat 公司) | Ubuntu  |  
| 社群单位 | Fedora <br/> Centos <br/> OpenSUSE | Debian <br/> B2D |  

## 3. Linux 安装  
linux中，所有的装置都会被当做一个文件来对待。  

#### 分区  
```
/boot
/
/home
/var
Swap
```  

## 4.命令  
#### 目录操作：  
```
cd： // 变换目录
pwd: // 显示当前目录
mkdir: // 建立一个目录
rmdir: // 删除一个目录
```

#### 环境变量: $PATH  
将指定目录(/root)添加到$PATH中:  
```
PATH = "${PATH}:/root"
```  


* 不同身份使用者预设的PATH不同，能随意执行的命令也不同
* PATH能被修改
* 使用绝对路径或相对路径来执行指令，比搜寻PATH来的正确  


#### 文件与目录管理  
```
ls: //查询
cp: //复制
rm: //删除
mv: //移动（更名）
```  

*cp命令注意：*  
* 是否需要完整的保留来源文件的信息 
* 来源是否为链接档
* 来源档是否为特殊的文件
* 来源文件是否为目录

#### 获取文件名与目录名称:  
```
basename /etc/sysconfig/network   => network 文件名

dirname /etc/sysconfig/network    => /etc/sysconfig 目录名
```

#### 文件内容查阅  

```
cat // 从文件第一行开始显示内容
tac // 从最后一行开始显示（cat的倒序）
nl // 显示的时候，顺带输出行号
more // 一页一页的显示文件内容
less // 与more类似，但是可以往前翻页
head // 只看头几行
tail //只看最后几行
od // 以二进制的方式读取文件内容
```  

#### 文件搜索
* 脚本文件搜索,例如 which ls，显示ls脚本文件位置  

原理：通过寻找PATH规定的目录来寻找，当命令为内置命令是如which history。则找不到，因为 history 命令是内置的，不是处于PATH目录中  

```
which [command]
type [command]
```  

* 搜索文件  

建议： 先使用whereis，locate来检查，实在找不到才用find  
```
find  // 不常用，因为是全局搜索硬盘
whereis // 查找系统中某些特定目录底下的文件
 -l 列出whereis会查询的几个主要目录

locate // 利用数据库来搜索文件名。 数据库: /var/lib/mlocate
```

locate的限制: 数据库默认更新执行一次，所以如果是新建立的文件，那么在数据库更新之前，是找不到的。  
可以手动更新数据库，通过updatedb命令。 updatedb会读取/etc/updatedb.conf这个配置文件，然后再去硬盘里面搜索文件名，最后更新数据库。  

find: 
```
find [PATH] [option] [action]  在PATH路径下查找  

选项：
-name filename： find / -name nginx.conf 
查找/路径下名称为nginx.conf的文件 

find / -name passwd       : 查找passwd这个文件
find / -name "*passwd*"   : 查找名称包含passwd关键词 的文件
```

#### 权限
* 要能 cd 进入某目录，则需要对目录具有x，可执行的权限
* 要能在某目录ls，则要有该目录的r 读权限

## 3. 压缩
```
格式： 
*.Z   compress程序压缩
*.zip  zip压缩
*.gz  gzip压缩
*.bz2 bzip2压缩
*.xz  xz压缩
*.tar  tar打包，没有压缩
*.tar.gz tar打包，且gzip压缩
*.tar.bz2  tar打包，bz2压缩
*.tar.xz   tar打包 xz压缩
```  

gzip => zcat/zmore/zless/zgrep: 除gzip外，其它的命令zcat,zless用于读取被压缩之后的 .gz 文件  

bzip2 => bzcat/bzmore/bzless  

xz => ...  

#### 打包 tar  

## 4. bash  

为了方便shell的操作，bash内置了很多的指令：可以查询指令是否为bash shell的内置命令: type  

```
type cd : cd is a shell builtin // 内置命令

type -a ls
ls is aliased to `ls --color=auto` // 找到alias
ls is /usr/bin/ls   // 找到外部指令  
```  

#### 变量
读取变量： echo $PATH  或者 echo ${PATH}  
设置变量: KEY=VALUE // =之间不能有**空格**，设置KEY的值为VALUE  

规则:
* 变量与变量内容之间用 = 连接: `key=value`  
* 等号两边不能有空格符
* 变量名称只能是英文字母或数字，但开头不能是数字
* 变量内容有空格则用单双引号括起来: `var = "lang is $LANG"`
* 若为变量扩增内容时，可使用$变量名称来累加: `PATH="$PATH":/home/bin`  
* 若该变量需要在子程序中执行，需要用 `export` 使其变成环境变量。 `export PATH`.  
* 取消变量用 `unset 变量名称`: `unset myname`  

#### 子程序
```
name='123'
bash    // 进入子程序
echo $name      // 为空，没有内容  
exit      // 退出子程序

export name // name成为环境变量
bash        // 再次进入子程序
echo $name   // 123 正常输出
```  
就是说，在当前shell的情况下，去启用另一个新的shell，新的shell就是子程序。一般父程序的 `自定义变量`无法被子程序使用，但是 `export`之后成为环境变量，子程序能够读取环境变量。  

#### 环境变量
查询默认的环境变量:  `env`,`export`都能查出当前所有的环境变量  

`set` 查看所有变量（自定义变量+环境变量  
tips: set显示的变量中, `PS1`为提示字符的设定，比如显示[用户名/用户组信息]  


`export`: 自定义变量转环境变量。*子程序会继承父程序的环境变量，但不会继承父程序的自定义变量*  


*变量内容也可以被删除*  


#### 别名 alias unalias  

#### bash环境配置文件  
~/.bash_profile : 只要存在该文件，则接下来的两个文件不会被读取  
~/.bash_login  
~/.profile  
`/etc/bashrc`  


#### 终端机的环境设定: stty, set
如可以利用退格键删除字符，利用ctrl + c 终止指令，都是通过 `stty` 决定的。  


#### 数据流重定向: [<, <<, >, >>, 2>, 2>>]    （略）
实现如将屏幕输出信息保存起来。  

#### 命令执行依据: ;,&&,||  
; 不考虑指令连续性，即无论前面命令成功失败，都会继续执行接下来的命令  
&& 只有前面的执行成功才会继续执行  
|| 前面的命令发生错误则执行后续的，否则不执行  

#### 管线命令 pipe  
将前一个指令传来的`正确`信息（不能处理错误信息），传给后续的命令。  后一个指令必须能接受输入。  

```
ls -al /etc | less 用less命令来查看ls的执行结果  
```  

#### 数据撷取  cut grep  
cut: 所有信息当中，一行一行分析，如果一行的信息当中有我们需要的信息，则取出该 `信息`  
grep：所有信息当中，一行一行分析，如果一行的信息当中有我们需要的信息，则取出该 `行`   

#### 排序 sort, wc, uniq  
sort:  进行排序  
uniq： 重复资料只显示一个  
wc: 计算文件多少个字，多少行，多少字符  


#### 双向重定向 tee  
将数据流分别保存到文件，和显示在屏幕。 

## 5. 账号管理  
添加用户:  useradd  
授予密码:  passwd  
usermod, userdel  