## 前言

之前看同事遇到浏览器缓存问题，就会用 curl 来执行一下请求。在同事看来，`curl` 是最为纯粹的请求工具，而在浏览器中发起请求，指不定浏览器会给你带上什么。  

刚好看到阮一峰前辈的文章，在此闲暇之际，便边阅读边实践，同时记录下来用于备忘。

测试代码:  

```js
const express = require('express')
const cookieParser = require('cookie-parser')
const bodyParser = require('body-parser')
const app = express()
const port = 3000

app.use(cookieParser())
// parse application/x-www-form-urlencoded
用于解析 `curl -d 'a=1&b=2' -H 'Content-Type: application/x-www-form-urlencoded' http://localhost:3000` 的情况
app.use(bodyParser.urlencoded({ extended: false }))

// parse application/json
用于解析 `curl -d '{"a": "1", "b": "2"}' -H 'Content-Type: application/json' http://localhost:3000` 的情况
app.use(bodyParser.json())

app.get('/', (req, res) => {
  console.log('get 请求!');
  // your test code
  // req.query
  // req.headers['']
  // req.cookies
  res.send('Hello World!')
})

app.post('/', (req, res) => {
  console.log('post 请求!');
  // your test code
  // req.body
  res.send('Hello World!')
})

app.listen(port, () => console.log(`Example app listening on port ${port}!`))
```

## 1. get 请求
不带任何参数，默认为 get 请求

`curl http://localhost:3000` 将返回 html 页面。经过测试，`curl http://localhost:3000` 和直接 `curl localhost:3000` 是一样的

## 2. -A

-A 参数用于指定 User Agent  

`curl http://localhost:3000`  
`req.headers['user-agent']` 等于 `curl/7.54.0`  

`curl -A '' http://localhost:3000`  
`req.headers['user-agent']` 等于 `undefined`,即会**移除** `User-Agent`  

`curl -A 'Mozilla/5.0' http://localhost:3000`  
`req.headers['user-agent']` 等于 `Mozilla/5.0`  

同样可以直接使用 `-H` 指定 `User-Agent`.  
`curl -H 'User-Agent: Mozilla/5.1' http://localhost:3000`  
`req.headers['user-agent']` 等于 `Mozilla/5.1`  

## 3. -b 

-b 参数用于向服务器发送 cookie, 等同于 `--cookie`  

在使用 express 进行测试前，需安装 `cookie-parser`  

`curl http://localhost:3000`  
`req.cookies` 等于 `{}`  

`curl -b 'foo=bar' http://localhost:3000`  
`req.cookies` 等于 `{ foo: bar }`  

在 [curl 的用法指南](https://www.ruanyifeng.com/blog/2019/09/curl-reference.html) 中，写着以下代码会发送两个 cookie， 但是经过测试，发现并没有，后端只能得到 `foo2` 这个 cookie。  

`curl -b "foo1=bar1" -b "foo2=bar2" http://localhost:3000`  
而以下这种写法，可以发送两个 cookie。  
`curl -b "foo1=bar1;foo2=bar2" localhost:3000`  

另外通过 `curl -b cookies.txt localhost:3000` 可以将 cookies.txt 中的 cookie 信息发送到服务端:  

cookie.txt(可以是相对路径，该文件可由 curl -c 生成，-c 命令待会讲)
```js
# Netscape HTTP Cookie File
# https://curl.haxx.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

localhost	FALSE	/	FALSE	0	cookieName	cookieValue
```

## 4. -c

-c 参数可以将服务器设置(set-cookie)的 cookie，保存到文件中:  

```js
// app.js
app.get('/', (req, res) => {
  res.cookie('cookieName', 'cookieValue')  // 服务端设置 cookie
  res.send('Hello World!')
})
```

`curl -c cookies.txt http://localhost:3000` 可将返回的 cookie `{cookieName: cookieValue}` 生成 cookies.txt 文件。  

## 5. -d
-d 参数用于发送 POST 请求的数据体,且 -d 参数可以多次使用，增加多个参数  

如 `-d "a=1" -d "b=2"` 等效于 `-d "a=1&b=2"`  

在使用 express 进行测试前，需安装 `body-parser`  

使用-d参数以后，HTTP 请求会自动加上请求头 `Content-Type : application/x-www-form-urlencoded`, 因此需要使用 `app.use(bodyParser.urlencoded({ extended: false }))` 来解析参数

发送 POST 请求可以通过:  
`curl -X POST http://localhost:3000` **POST 必须为大写**  

同理: `curl -X GET http://localhost:3000` 可以发送 GET 请求，但 **GET 必须为大写**  

`curl -X POST -d "a=1&b=2" http://localhost:3000` 可以向后端传输数据。  
`req.body` 等于 `{a:1,b:2}`  

当使用 -d 时，会自动使用 `-X POST`,因此可以省略 `-X POST`  
`curl -d "a=1&b=2" http://localhost:3000`  

## 6. --data-urlencode
--data-urlencode 参数和 -d 一样，区别在于:  

```js
curl -X POST --data-urlencode "a= 1 3 &b=2" http://localhost:3000  
解析之后: { a: " 1 3 &b=2"}

curl -X POST -d "a= 1 3 &b=2" http://localhost:3000  
解析之后: { a: " 1 3 ", b:2 }
```

## 7. -e

-e 用于指定 HTTP 的 Referer 的值

`curl http://localhost:3000`  
`req.get('Referer')` 等于 `undefined`  

`curl -e 'test referer' http://localhost:3000`  
`req.get('Referer')` 等于 `test referer`  

同样，可以通过设置 -H 参数设置 Referer  

`curl -H 'Referer: test referer' http://localhost:3000`  
`req.get('Referer')` 等于 `test referer`  

## 8. -F

-F 用于像服务器传输二进制文件(略)

## 9. -G

-G 用于构造Get请求的 URL 的查询字符串  

Get 的查询参数，如下:  
`curl  http://localhost:3000?a=1&b=2` 
`req.query` 等于 `{a:1,b:2}`  

同样可以用 -G -d 来构造 Get 请求的查询参数  

`curl -G -d "a=1&b=2" -d "c=3" http://localhost:3000` 等效于  
`curl -G -d "a=1" -d "b=2" -d "c=3" http://localhost:3000`  
`req.query` 等于 `{a:1,b:2,c:3}`

## 10. -H 

-H 参数用于添加 HTTP 请求头  

`curl  -H 'a: b' http://localhost:3000`  
`req.headers` 等于 `{a:b}`  

可以多次使用，添加多个请求头:  
`curl -H 'Accept-Language: en-US' -H 'Secret-Message: xyzzy'  http://localhost:3000`  
`req.headers` 等于 `{ 'accept-language': 'en-US', 'secret-message': 'xyzzy' }`  

可以通过 -H 指定请求头，再使用 -d 发送 JSON 数据:  
`curl -d '{"a": "1", "b": "2"}' -H 'Content-Type: application/json' http://localhost:3000`  
`req.body` 等于 `{a:1,b:2}`  

## 11. -i 

-i 参数用于 **在输出服务器内容之前**，先输出服务器返回的响应头:  

`curl -i http:localhost:3000`  

返回:  

```
HTTP/1.1 200 OK     // 响应头信息
X-Powered-By: Express
Set-Cookie: cookieName=cookieValue; Path=/
Content-Type: text/html; charset=utf-8
Content-Length: 12
ETag: W/"c-Lve95gjOVATpfV8EL5X4nxwjKHE"
Date: Tue, 28 Jan 2020 05:22:37 GMT
Connection: keep-alive

Hello World!        // 真正的响应内容
```

## 12. -I

-I 参数用于发送 HEAD 请求，参考 [MDN HEAD 请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD)  

HEAD 请求用于获取资源的 **响应头信息**，不包含真正的响应内容。该请求方法的一个使用场景是在**下载一个大文件前先获取其大小再决定是否要下载**, 以此可以节约带宽资源。  

`curl -I http://localhost:3000`  

`--head` 等同于 `-I`, 即 `curl -I http://localhost:3000` 等效于 `curl --head http://localhost:3000`
返回:  
```
HTTP/1.1 200 OK           // 即只有响应头
X-Powered-By: Express
Set-Cookie: cookieName=cookieValue; Path=/
Content-Type: text/html; charset=utf-8
Content-Length: 12
ETag: W/"c-Lve95gjOVATpfV8EL5X4nxwjKHE"
Date: Tue, 28 Jan 2020 05:31:31 GMT
Connection: keep-alive
```

## 13. -k

-k 参数用于跳过 SSL 证书检查。  

`curl -k https://www.example.com`  

上述请求不会校验服务器的 SSL 证书是否正确。

## 14. -L

-L 参与用于让 HTTP 请求跟随服务器的重定向， curl 默认不跟随重定向。  
`curl http://www.google.com` 返回很简短的一段 302 响应 HTML,因为 google 官网域名是在 `https`，`http` 访问的时候，需要经过重定向才能访问到 `https`，不加 -L 时，不进行重定向:  

```html
<H1>302 Moved</H1>
```

`curl -L http://www.google.com`，会跟随重定向，返回 `https://www.google.com` 的页面.  

*疑问: 测试 http://www.baidu.com 的时候，curl http://www.baidu.com 会返回全部内容，而不是 302 的响应*  

## 15. --limit-rate

--limit-rate 用于限制 HTTP 请求和回应的宽带，模拟慢网速环境  

## 16. -o

-o 参数用于将服务器的响应，保存为文件,相当于 `wget` 命令  

`curl -o save.html http://localhost:3000`  
上诉命令将 http:localhost:3000 的返回内容，保存为 `save.html`  

## 17. -O

-O 参数和 -o 基本类似，区别在于 -O 参数将服务器的响应保存成文件,无需手动指定名字，会自动将 **URL 的最后部分当作文件名**。  

`curl -O https://www.ruanyifeng.com/blog/2019/09/curl-reference.html`  

将保存为 curl-reference.html 文件。  

> 经过测试, curl -O http:localhost:3000 无效，应该是因为 URL 的最后部分没有可以用作文件名的。  

## 18. -s

-s 参数将不输出进度信息，和错误信息  

如 `curl -O https://www.ruanyifeng.com/blog/2019/09/curl-reference.html` 会输出下载进度信息。 

`curl -O -s https://www.ruanyifeng.com/blog/2019/09/curl-reference.html` 就不会再输出进度信息。

## 19. -S 

-S 参数用于 **只输出错误信息**  

## 20. -u

-u 参数用于设置服务器认证的用户名和密码:  

`curl -u 'bob:12345' localhost:3000` 设置用户名为 bob, 密码为 12345 。后端服务器的请求头得到 `req.headers = { authorization: 'Basic Ym9iOjEyMzQ1'}`  

`curl -u 'bob:12346' localhost:3000` 设置用户名为 bob, 密码为 12346 。后端服务器的请求头得到 `req.headers = { authorization: 'Basic Ym9iOjEyMzQ2'}`  

## 21. -v

-v 参数可以输出通信的整个过程，包含客户端发送的数据和服务端返回的信息，可用于调试。  

命令: `curl -v -b "a=1" http://localhost:3000`

返回:  

```js
--------------------- 客户端发送的数据
* Rebuilt URL to: http://localhost:3000/
*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost (::1) port 3000 (#0)
> GET / HTTP/1.1
> Host: localhost:3000
> User-Agent: curl/7.54.0
> Accept: */*
> Cookie: a=1         // 发送的 cookie
>             ----- 客户端发送数据结束，服务端返回数据开始
< HTTP/1.1 200 OK
< X-Powered-By: Express
< Set-Cookie: cookieName=cookieValue; Path=/
< Content-Type: text/html; charset=utf-8
< Content-Length: 12
< ETag: W/"c-Lve95gjOVATpfV8EL5X4nxwjKHE"
< Date: Tue, 28 Jan 2020 06:09:39 GMT
< Connection: keep-alive
< 
* Connection #0 to host localhost left intact
Hello World!%                               
             -----  服务端返回数据结束
```

`--trace -` <URL> 也可以用于调试:  

`curl  -b "a=1" --trace - http://localhost:3000`  

可以输出二进制原始数据(但没必要，二进制数据也读不懂)

## 22. -x  

*未测试*  

-x 参数可以用以指定 HTTP 请求的代理  

`curl -x socks5://james:cats@myproxy.com:8080 https://www.example.co`  

以上命令指定，最终请求 `https://www.example.co`, 但是请求时经过了 `socks5://james:cats@myproxy.com:8080` 代理服务器。  

其中 `socks5` 是代理服务器的协议。

## 23. -X

-X 参数用于指定请求的方式,如  

GET请求:  `curl -X GET http://localhost:3000`  

POST请求:  `curl -X POST http://localhost:3000`  

其中要注意的是，**POST GET 等方法必须大写**  

<hr />

可使用 `curl --help` 查看更多信息

## 参考资料

1. [curl 的用法指南](https://www.ruanyifeng.com/blog/2019/09/curl-reference.html) 